<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Elastic-JOB</title>
    <link>http://dangdangdotcom.github.io/elastic-job/post/</link>
    <description>Recent content in Posts on Elastic-JOB</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 Jan 2016 16:14:21 +0800</lastBuildDate>
    <atom:link href="http://dangdangdotcom.github.io/elastic-job/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Release Notes</title>
      <link>http://dangdangdotcom.github.io/elastic-job/post/release_notes/</link>
      <pubDate>Wed, 27 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/elastic-job/post/release_notes/</guid>
      <description>

&lt;h1 id=&#34;release-notes:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;Release Notes&lt;/h1&gt;

&lt;h2 id=&#34;1-0-6-snapshot:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;1.0.6-SNAPSHOT&lt;/h2&gt;

&lt;h3 id=&#34;功能提升:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;功能提升&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/71&#34;&gt;ISSUE #71&lt;/a&gt; 作业关闭功能（shutdown）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/72&#34;&gt;ISSUE #72&lt;/a&gt; 关闭的作业可删除&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;缺陷修正:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;缺陷修正&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/69&#34;&gt;ISSUE #69&lt;/a&gt; 分片时如在Zk中有的作业服务器sharding节点不存在将导致无法重新分片&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-0-5:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;1.0.5&lt;/h2&gt;

&lt;h3 id=&#34;功能提升-1:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;功能提升&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/2&#34;&gt;ISSUE #2&lt;/a&gt; 增加前置和后置任务&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/60&#34;&gt;ISSUE #60&lt;/a&gt; 可于DataFlow类型作业定制化线程池配置&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/61&#34;&gt;ISSUE #62&lt;/a&gt; 作业状态清理提速&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/65&#34;&gt;ISSUE #65&lt;/a&gt; 增加前置和后置任务Spring命名空间支持&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;缺陷修正-1:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;缺陷修正&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/61&#34;&gt;ISSUE #61&lt;/a&gt; 分片和主节点选举同时发生时，死锁问题解决&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/63&#34;&gt;ISSUE #63&lt;/a&gt; 获取作业TreeCache时可能会获取到前缀相同的其他作业的TreeCache&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;结构调整:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;结构调整&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/59&#34;&gt;ISSUE #59&lt;/a&gt; 将elastic-job依赖的curator从&lt;code&gt;2.8.0&lt;/code&gt;升级至&lt;code&gt;2.10.0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-0-4:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;1.0.4&lt;/h2&gt;

&lt;h3 id=&#34;功能提升-2:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;功能提升&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/16&#34;&gt;ISSUE #16&lt;/a&gt; 提供内嵌zookeeper，简化开发环境&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/28&#34;&gt;ISSUE #28&lt;/a&gt; DataFlow类型作业增加&lt;code&gt;processData&lt;/code&gt;批量处理数据的方法&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/56&#34;&gt;ISSUE #56&lt;/a&gt; 作业自定义参数设置&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;结构调整-1:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;结构调整&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/57&#34;&gt;ISSUE #57&lt;/a&gt; 精简模块，移除&lt;code&gt;elastic-job-test&lt;/code&gt;模块&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/58&#34;&gt;ISSUE #58&lt;/a&gt; 增加批量处理功能导致的作业类型接口变更&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-0-3:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;1.0.3&lt;/h2&gt;

&lt;h3 id=&#34;功能提升-3:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;功能提升&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/39&#34;&gt;ISSUE #39&lt;/a&gt; 增加作业辅助监听功能，通过dump命令抓取作业运行时信息&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/43&#34;&gt;ISSUE #43&lt;/a&gt; 增加作业异常处理回调接口&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;缺陷修正-2:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;缺陷修正&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/30&#34;&gt;ISSUE #30&lt;/a&gt; 注册中心宕机较长时间后重新恢复，作业无法继续执行&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/36&#34;&gt;ISSUE #36&lt;/a&gt; 任务在控制台暂停之后，无法恢复运行&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/40&#34;&gt;ISSUE #40&lt;/a&gt; TreeCache使用粒度过粗导致内存溢出&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-0-2:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;1.0.2&lt;/h2&gt;

&lt;h3 id=&#34;功能提升-4:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;功能提升&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/6&#34;&gt;ISSUE #6&lt;/a&gt; 校对作业服务器与注册中心时间误差&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/8&#34;&gt;ISSUE #8&lt;/a&gt; 增加misfire开关，默认开启错过任务重新执行&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/9&#34;&gt;ISSUE #9&lt;/a&gt; 分片策略可配置化&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/10&#34;&gt;ISSUE #10&lt;/a&gt; 提供根据作业名称hash值取奇偶数分片排序策略&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/14&#34;&gt;ISSUE #14&lt;/a&gt; 控制台修改cron表达式后，任务将实时更新cron&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/20&#34;&gt;ISSUE #20&lt;/a&gt; 运维界面任务列表显示增加cron表达式&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/54&#34;&gt;ISSUE #54&lt;/a&gt; SequencePerpetual类型作业性能提升，将抓取数据改为多线程，之前仅处理数据为多线程&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/55&#34;&gt;ISSUE #55&lt;/a&gt; offset存储功能&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;缺陷修正-3:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;缺陷修正&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/1&#34;&gt;ISSUE #1&lt;/a&gt; 复杂网络环境下IP地址获取不准确的问题&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/13&#34;&gt;ISSUE #13&lt;/a&gt; 作业抛出运行时异常后，后续不会继续触发&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/53&#34;&gt;ISSUE #53&lt;/a&gt; Dataflow的Sequence类型作业采用多线程抓取数据&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;结构调整-2:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;结构调整&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job/issues/17&#34;&gt;ISSUE #17&lt;/a&gt; 作业类型接口变更，参见&lt;a href=&#34;http://dangdangdotcom.github.io/elastic-job/post/update_notes_1.0.2/&#34;&gt;1.0.2升级说明&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-0-1:0e7a0379e76a8b6dfd2072d5a9672bab&#34;&gt;1.0.1&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;初始版本&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>elastic-job 1.0.2升级说明</title>
      <link>http://dangdangdotcom.github.io/elastic-job/post/update_notes_1.0.2/</link>
      <pubDate>Wed, 27 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/elastic-job/post/update_notes_1.0.2/</guid>
      <description>

&lt;h1 id=&#34;elastic-job-1-0-2升级说明:222edb4b4fef6afb18e150da049887bf&#34;&gt;elastic-job 1.0.2升级说明&lt;/h1&gt;

&lt;p&gt;为了扩展性和概念明晰，&lt;code&gt;elastic-job 1.0.2&lt;/code&gt;重新定义了作业类型。&lt;/p&gt;

&lt;h2 id=&#34;plugin包:222edb4b4fef6afb18e150da049887bf&#34;&gt;plugin包&lt;/h2&gt;

&lt;p&gt;为了扩展方便，将作业类型由&lt;code&gt;api&lt;/code&gt;包挪入&lt;code&gt;plugin&lt;/code&gt;包，欢迎大家贡献自己的作业类型到&lt;code&gt;plugin&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;重新定义并明晰作业类型:222edb4b4fef6afb18e150da049887bf&#34;&gt;重新定义并明晰作业类型&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原&lt;code&gt;OneOff&lt;/code&gt;更名为&lt;code&gt;Simple&lt;/code&gt;类型，意为简单实现，未经任何封装的类型。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提炼抽象出&lt;code&gt;DataFlow&lt;/code&gt;类型用于处理数据流。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;原&lt;code&gt;Perpetual&lt;/code&gt;更名为&lt;code&gt;ThroughputDataFlow&lt;/code&gt;类型，意为高吞吐的数据流作业。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;原&lt;code&gt;SequencePerpetual&lt;/code&gt;更名为&lt;code&gt;SequenceDataFlow&lt;/code&gt;类型，意为顺序性数据流作业。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;DataFlow&lt;/code&gt;父接口增加&lt;code&gt;isStreamingProcess&lt;/code&gt;接口，意为数据流类型作业是否使用流式处理（即，有数据则一直不停止作业的处理 &amp;ndash; 对应原&lt;code&gt;Perpetual&lt;/code&gt;概念，还是任务中只执行一次抓取/处理 &amp;ndash; 对应原&lt;code&gt;OneOff&lt;/code&gt;概念）。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;迁移作业调度器类:222edb4b4fef6afb18e150da049887bf&#34;&gt;迁移作业调度器类&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;迁移意义不明的&lt;code&gt;schedule&lt;/code&gt;包，将其拆分至&lt;code&gt;api&lt;/code&gt;和&lt;code&gt;internal&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;com.dangdang.ddframe.job.schedule.JobController&lt;/code&gt;更名为&lt;code&gt;com.dangdang.ddframe.job.api.JobScheduler&lt;/code&gt;，如果使用原生类启动作业，请更新。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;com.dangdang.ddframe.job.spring.schedule.SpringJobController&lt;/code&gt;更名为&lt;code&gt;com.dangdang.ddframe.job.spring.schedule.SpringJobScheduler&lt;/code&gt;，如果使用非&lt;code&gt;Spring&lt;/code&gt;命名空间启动作业，请更新。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;兼容性问题:222edb4b4fef6afb18e150da049887bf&#34;&gt;兼容性问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;将原抽象类升级为接口，所以如果之前使用&lt;code&gt;protected&lt;/code&gt;实现&lt;code&gt;fetchData&lt;/code&gt;，&lt;code&gt;processData&lt;/code&gt;等方法，需要改为&lt;code&gt;public&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;其余改动的接口，包括&lt;code&gt;AbstractOneOffElasticJob&lt;/code&gt;，&lt;code&gt;AbstractPerpetualElasticJob&lt;/code&gt;和&lt;code&gt;AbstractSequencePerpetualElasticJob&lt;/code&gt;均将以&lt;code&gt;@Deprecated&lt;/code&gt;的形式继续存在一段时间，不会导致升级版本产生兼容问题。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>何为分布式作业？</title>
      <link>http://dangdangdotcom.github.io/elastic-job/post/distribution/</link>
      <pubDate>Wed, 27 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/elastic-job/post/distribution/</guid>
      <description>

&lt;h1 id=&#34;何为分布式作业:2923f63596206c753f4fc3f7d0115ba2&#34;&gt;何为分布式作业？&lt;/h1&gt;

&lt;h2 id=&#34;分片概念:2923f63596206c753f4fc3f7d0115ba2&#34;&gt;分片概念&lt;/h2&gt;

&lt;p&gt;任务的分布式执行，需要将一个任务拆分为n个独立的任务项，然后由分布式的服务器分别执行某一个或几个分片项。&lt;/p&gt;

&lt;p&gt;例如：有一个遍历数据库某张表的作业，现有&lt;code&gt;2&lt;/code&gt;台服务器。为了快速的执行作业，那么每台服务器应执行作业的&lt;code&gt;50%&lt;/code&gt;。
为满足此需求，可将作业分成&lt;code&gt;2&lt;/code&gt;片，每台服务器执行&lt;code&gt;1&lt;/code&gt;片。作业遍历数据的逻辑应为：服务器&lt;code&gt;A&lt;/code&gt;遍历&lt;code&gt;ID&lt;/code&gt;以奇数结尾的数据；服务器&lt;code&gt;B&lt;/code&gt;遍历&lt;code&gt;ID&lt;/code&gt;以偶数结尾的数据。
如果分成&lt;code&gt;10&lt;/code&gt;片，则作业遍历数据的逻辑应为：每片分到的分片项应为&lt;code&gt;ID%10&lt;/code&gt;，而服务器A被分配到分片项&lt;code&gt;0,1,2,3,4&lt;/code&gt;；服务器B被分配到分片项&lt;code&gt;5,6,7,8,9&lt;/code&gt;，直接的结果就是服务器&lt;code&gt;A&lt;/code&gt;遍历&lt;code&gt;ID&lt;/code&gt;以&lt;code&gt;0-4&lt;/code&gt;结尾的数据；服务器&lt;code&gt;B&lt;/code&gt;遍历&lt;code&gt;ID&lt;/code&gt;以&lt;code&gt;5-9&lt;/code&gt;结尾的数据。&lt;/p&gt;

&lt;h2 id=&#34;分片项与业务处理解耦:2923f63596206c753f4fc3f7d0115ba2&#34;&gt;分片项与业务处理解耦&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Elastic-job&lt;/code&gt;并不直接提供数据处理的功能，框架只会将分片项分配至各个运行中的作业服务器，开发者需要自行处理分片项与真实数据的对应关系。&lt;/p&gt;

&lt;h2 id=&#34;分布式作业的执行:2923f63596206c753f4fc3f7d0115ba2&#34;&gt;分布式作业的执行&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Elastic-job&lt;/code&gt;并无作业调度中心节点，而是基于部署作业框架的程序在到达相应时间点时各自触发调度。&lt;/p&gt;

&lt;p&gt;注册中心仅用于作业注册和监控信息存储。而主作业节点仅用于处理分片和清理等功能。&lt;/p&gt;

&lt;h2 id=&#34;个性化参数的适用场景:2923f63596206c753f4fc3f7d0115ba2&#34;&gt;个性化参数的适用场景&lt;/h2&gt;

&lt;p&gt;个性化参数即&lt;code&gt;shardingItemParameters&lt;/code&gt;，可以和分片项匹配对应关系，用于将分片项的数字转换为更加可读的业务代码。&lt;/p&gt;

&lt;p&gt;例如：按照地区水平拆分数据库，数据库&lt;code&gt;A&lt;/code&gt;是北京的数据；数据库&lt;code&gt;B&lt;/code&gt;是上海的数据；数据库&lt;code&gt;C&lt;/code&gt;是广州的数据。
如果仅按照分片项配置，开发者需要了解&lt;code&gt;0&lt;/code&gt;表示北京；&lt;code&gt;1&lt;/code&gt;表示上海；&lt;code&gt;2&lt;/code&gt;表示广州。
合理使用个性化参数可以让代码更可读，如果配置为&lt;code&gt;0=北京&lt;/code&gt;,&lt;code&gt;1=上海&lt;/code&gt;,&lt;code&gt;2=广州&lt;/code&gt;，那么代码中直接使用北京，上海，广州的枚举值即可完成分片项和业务逻辑的对应关系。&lt;/p&gt;

&lt;h2 id=&#34;作业高可用:2923f63596206c753f4fc3f7d0115ba2&#34;&gt;作业高可用&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Elastic-job&lt;/code&gt;提供最安全的方式执行作业。将分片项设置为&lt;code&gt;1&lt;/code&gt;，并使用多于&lt;code&gt;1&lt;/code&gt;台的服务器执行作业，作业将会以&lt;code&gt;1&lt;/code&gt;主&lt;code&gt;n&lt;/code&gt;从的方式执行。&lt;/p&gt;

&lt;p&gt;一旦执行作业的服务器崩溃，等待执行的服务器将会在下次作业启动时替补执行。
开启失效转移功能效果更好，可以保证在本次作业执行时崩溃，备机立即启动替补执行。&lt;/p&gt;

&lt;h2 id=&#34;最大限度利用资源:2923f63596206c753f4fc3f7d0115ba2&#34;&gt;最大限度利用资源&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Elastic-job&lt;/code&gt;也提供最灵活的方式，最大限度的提高执行作业的吞吐量。将分片项设置为大于服务器的数量，最好是大于服务器倍数的数量，作业将会合理的利用分布式资源，动态的分配分片项。&lt;/p&gt;

&lt;p&gt;例如：&lt;code&gt;3&lt;/code&gt;台服务器，分成&lt;code&gt;10&lt;/code&gt;片，则分片项分配结果为服务器&lt;code&gt;A=0,1,2&lt;/code&gt;;服务器&lt;code&gt;B=3,4,5&lt;/code&gt;;服务器&lt;code&gt;C=6,7,8,9&lt;/code&gt;。
如果服务器&lt;code&gt;C&lt;/code&gt;崩溃，则分片项分配结果为服务器&lt;code&gt;A=0,1,2,3,4&lt;/code&gt;;服务器&lt;code&gt;B=5,6,7,8,9&lt;/code&gt;。在不丢失分片项的情况下，最大限度的利用现有资源提高吞吐量。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>目录结构说明</title>
      <link>http://dangdangdotcom.github.io/elastic-job/post/directory_structure/</link>
      <pubDate>Wed, 27 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/elastic-job/post/directory_structure/</guid>
      <description>

&lt;h1 id=&#34;目录结构说明:b4b5a29fe5be663d2644d30f96759d37&#34;&gt;目录结构说明&lt;/h1&gt;

&lt;h2 id=&#34;elastic-job-core:b4b5a29fe5be663d2644d30f96759d37&#34;&gt;elastic-job-core&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;elastic-job&lt;/code&gt;核心模块，只通过&lt;code&gt;Quartz&lt;/code&gt;和&lt;code&gt;Curator&lt;/code&gt;就可执行分布式作业。&lt;/p&gt;

&lt;h2 id=&#34;elastic-job-spring:b4b5a29fe5be663d2644d30f96759d37&#34;&gt;elastic-job-spring&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;elastic-job&lt;/code&gt;对&lt;code&gt;spring&lt;/code&gt;支持的模块，包括命名空间，依赖注入，占位符等。&lt;/p&gt;

&lt;h2 id=&#34;elastic-job-console:b4b5a29fe5be663d2644d30f96759d37&#34;&gt;elastic-job-console&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;elastic-job web&lt;/code&gt;控制台，可将编译之后的&lt;code&gt;war&lt;/code&gt;放入&lt;code&gt;tomcat&lt;/code&gt;等&lt;code&gt;servlet&lt;/code&gt;容器中使用。&lt;/p&gt;

&lt;h2 id=&#34;elastic-job-example:b4b5a29fe5be663d2644d30f96759d37&#34;&gt;elastic-job-example&lt;/h2&gt;

&lt;p&gt;使用示例。&lt;/p&gt;

&lt;h2 id=&#34;elastic-job-doc:b4b5a29fe5be663d2644d30f96759d37&#34;&gt;elastic-job-doc&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;markdown&lt;/code&gt;生成文档的项目，使用方无需关注。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用步骤</title>
      <link>http://dangdangdotcom.github.io/elastic-job/post/usage/</link>
      <pubDate>Wed, 27 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/elastic-job/post/usage/</guid>
      <description>

&lt;h1 id=&#34;使用步骤:dc32fe45042973266ca60588597e0b66&#34;&gt;使用步骤&lt;/h1&gt;

&lt;h2 id=&#34;安装java环境:dc32fe45042973266ca60588597e0b66&#34;&gt;安装Java环境&lt;/h2&gt;

&lt;p&gt;请使用&lt;code&gt;JDK1.7&lt;/code&gt;及其以上版本。&lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/downloads/index.html&#34;&gt;详情参见&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装zookeeper:dc32fe45042973266ca60588597e0b66&#34;&gt;安装Zookeeper&lt;/h2&gt;

&lt;p&gt;请使用&lt;code&gt;Zookeeper 3.4.6&lt;/code&gt;及其以上版本。&lt;a href=&#34;https://zookeeper.apache.org/doc/trunk/zookeeperStarted.html&#34;&gt;详情参见&lt;/a&gt;。或使用&lt;code&gt;elastic-job&lt;/code&gt;自带的内嵌&lt;code&gt;Zookeeper&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装maven:dc32fe45042973266ca60588597e0b66&#34;&gt;安装Maven&lt;/h2&gt;

&lt;p&gt;请使用&lt;code&gt;Maven 3.0.4&lt;/code&gt;及其以上版本。&lt;a href=&#34;http://maven.apache.org/install.html&#34;&gt;详情参见&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;引入elastic-job:dc32fe45042973266ca60588597e0b66&#34;&gt;引入elastic-job&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 引入elastic-job核心模块 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.dangdang&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;elastic-job-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${lasted.release.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- 使用springframework自定义命名空间时引入 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.dangdang&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;elastic-job-spring&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${lasted.release.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>开发指南</title>
      <link>http://dangdangdotcom.github.io/elastic-job/post/user_guide/</link>
      <pubDate>Wed, 27 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/elastic-job/post/user_guide/</guid>
      <description>

&lt;h1 id=&#34;开发指南:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;开发指南&lt;/h1&gt;

&lt;h2 id=&#34;代码开发:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;代码开发&lt;/h2&gt;

&lt;h3 id=&#34;作业类型:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;作业类型&lt;/h3&gt;

&lt;p&gt;目前提供&lt;code&gt;2&lt;/code&gt;种作业类型，分别是&lt;code&gt;Simple&lt;/code&gt;和&lt;code&gt;DataFlow&lt;/code&gt;。&lt;code&gt;DataFlow&lt;/code&gt;类型用于处理数据流，它又提供&lt;code&gt;2&lt;/code&gt;种作业类型，分别是&lt;code&gt;ThroughputDataFlow&lt;/code&gt;和&lt;code&gt;SequenceDataFlow&lt;/code&gt;。需要继承相应的抽象类。&lt;/p&gt;

&lt;p&gt;方法参数&lt;code&gt;shardingContext&lt;/code&gt;包含作业配置，分片和运行时信息。可通过&lt;code&gt;getShardingTotalCount()&lt;/code&gt;, &lt;code&gt;getShardingItems()&lt;/code&gt;等方法分别获取分片总数，运行在本作业服务器的分片序列号集合等。&lt;/p&gt;

&lt;h4 id=&#34;simple类型作业:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;Simple类型作业&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Simple&lt;/code&gt;类型作业意为简单实现，未经任何封装的类型。需要继承&lt;code&gt;AbstractSimpleElasticJob&lt;/code&gt;，该类只提供了一个方法用于覆盖，此方法将被定时执行。用于执行普通的定时任务，与&lt;code&gt;Quartz&lt;/code&gt;原生接口相似，只是增加了弹性扩缩容和分片等功能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyElasticJob extends AbstractSimpleElasticJob {
    
    @Override
    public void process(JobExecutionMultipleShardingContext context) {
        // do something by sharding items
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;throughputdataflow类型作业:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;ThroughputDataFlow类型作业&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;ThroughputDataFlow&lt;/code&gt;类型作业意为高吞吐的数据流作业。需要继承&lt;code&gt;AbstractThroughputDataFlowElasticJob&lt;/code&gt;并可以指定返回值泛型，该类提供&lt;code&gt;3&lt;/code&gt;个方法可覆盖，分别用于抓取数据，处理数据和指定是否流式处理数据。可以获取数据处理成功失败次数等辅助监控信息。如果流式处理数据，&lt;code&gt;fetchData&lt;/code&gt;方法的返回值只有为&lt;code&gt;null&lt;/code&gt;或长度为空时，作业才会停止执行，否则作业会一直运行下去；非流式处理数据则只会在每次作业执行过程中执行一次&lt;code&gt;fetchData&lt;/code&gt;方法和&lt;code&gt;processData&lt;/code&gt;方法，即完成本次作业。流式数据处理参照&lt;code&gt;TbSchedule&lt;/code&gt;设计，适用于不间歇的数据处理。&lt;/p&gt;

&lt;p&gt;作业执行时会将&lt;code&gt;fetchData&lt;/code&gt;的数据传递给&lt;code&gt;processData&lt;/code&gt;处理，其中&lt;code&gt;processData&lt;/code&gt;得到的数据是通过多线程（线程池大小可配）拆分的。如果采用流式作业处理方式，建议&lt;code&gt;processData&lt;/code&gt;处理数据后更新其状态，避免&lt;code&gt;fetchData&lt;/code&gt;再次抓取到，从而使得作业永远不会停止。&lt;code&gt;processData&lt;/code&gt;的返回值用于表示数据是否处理成功，抛出异常或者返回&lt;code&gt;false&lt;/code&gt;将会在统计信息中归入失败次数，返回&lt;code&gt;true&lt;/code&gt;则归入成功次数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyElasticJob extends AbstractThroughputDataFlowElasticJob&amp;lt;Foo&amp;gt; {
    
    @Override
    public List&amp;lt;Foo&amp;gt; fetchData(JobExecutionMultipleShardingContext context) {
        Map&amp;lt;Integer, String&amp;gt; offset = context.getOffsets();
        List&amp;lt;Foo&amp;gt; result = // get data from database by sharding items and by offset
        return result;
    }
    
    @Override
    public boolean processData(JobExecutionMultipleShardingContext context, Foo data) {
        // process data
        // ...
        
        // store offset
        for (int each : context.getShardingItems()) {
            updateOffset(each, &amp;quot;your offset, maybe id&amp;quot;);
        }
        return true;
    }
    
    @Override
    public boolean isStreamingProcess() {
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sequencedataflow类型作业:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;SequenceDataFlow类型作业&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;SequenceDataFlow&lt;/code&gt;类型作业和&lt;code&gt;ThroughputDataFlow&lt;/code&gt;作业类型极为相似，所不同的是&lt;code&gt;ThroughputDataFlow&lt;/code&gt;作业类型可以将获取到的数据多线程处理，但不会保证多线程处理数据的顺序。如：从&lt;code&gt;2&lt;/code&gt;个分片共获取到&lt;code&gt;100&lt;/code&gt;条数据，第&lt;code&gt;1&lt;/code&gt;个分片&lt;code&gt;40&lt;/code&gt;条，第&lt;code&gt;2&lt;/code&gt;个分片&lt;code&gt;60&lt;/code&gt;条，配置为两个线程处理，则第&lt;code&gt;1&lt;/code&gt;个线程处理前&lt;code&gt;50&lt;/code&gt;条数据，第&lt;code&gt;2&lt;/code&gt;个线程处理后&lt;code&gt;50&lt;/code&gt;条数据，无视分片项；&lt;code&gt;SequenceDataFlow&lt;/code&gt;类型作业则根据当前服务器所分配的分片项数量进行多线程处理，每个分片项使用同一线程处理，防止了同一分片的数据被多线程处理，从而导致的顺序问题。如：从&lt;code&gt;2&lt;/code&gt;个分片共获取到&lt;code&gt;100&lt;/code&gt;条数据，第&lt;code&gt;1&lt;/code&gt;个分片&lt;code&gt;40&lt;/code&gt;条，第&lt;code&gt;2&lt;/code&gt;个分片&lt;code&gt;60&lt;/code&gt;条，则系统自动分配两个线程处理，第&lt;code&gt;1&lt;/code&gt;个线程处理第&lt;code&gt;1&lt;/code&gt;个分片的&lt;code&gt;40&lt;/code&gt;条数据，第&lt;code&gt;2&lt;/code&gt;个线程处理第&lt;code&gt;2&lt;/code&gt;个分片的&lt;code&gt;60&lt;/code&gt;条数据。由于&lt;code&gt;ThroughputDataFlow&lt;/code&gt;作业可以使用多于分片项的任意线程数处理，所以性能调优的可能会优于&lt;code&gt;SequenceDataFlow&lt;/code&gt;作业。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyElasticJob extends AbstractIndividualSequenceDataFlowElasticJob&amp;lt;Foo&amp;gt; {
    
    @Override
    public List&amp;lt;Foo&amp;gt; fetchData(JobExecutionSingleShardingContext context) {
        int offset = context.getOffset();
        List&amp;lt;Foo&amp;gt; result = // get data from database by sharding items and by offset
        return result;
    }
    
    @Override
    public boolean processData(JobExecutionSingleShardingContext context, Foo data) {
        // process data
        // ...
        
        // store offset
        updateOffset(context.getShardingItem(), &amp;quot;your offset, maybe id&amp;quot;);
        return true;
    }
    
    @Override
    public boolean isStreamingProcess() {
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;批量处理:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;批量处理&lt;/h3&gt;

&lt;p&gt;为了提高数据处理效率，数据流类型作业提供了批量处理数据的功能。之前逐条处理数据的两个抽象类分别是&lt;code&gt;AbstractIndividualThroughputDataFlowElasticJob&lt;/code&gt;和&lt;code&gt;AbstractIndividualSequenceDataFlowElasticJob&lt;/code&gt;，批量处理则使用另外两个接口&lt;code&gt;AbstractBatchThroughputDataFlowElasticJob&lt;/code&gt;和&lt;code&gt;AbstractBatchSequenceDataFlowElasticJob&lt;/code&gt;。不同之处在于&lt;code&gt;processData&lt;/code&gt;方法的返回值从&lt;code&gt;boolean&lt;/code&gt;类型变为&lt;code&gt;int&lt;/code&gt;类型，用于表示一批数据处理的成功数量，第二个入参则转变为&lt;code&gt;List&lt;/code&gt;数据集合。&lt;/p&gt;

&lt;h3 id=&#34;异常处理:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;异常处理&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;elastic-job&lt;/code&gt;在最上层接口提供了&lt;code&gt;handleJobExecutionException&lt;/code&gt;方法，使用作业时可以覆盖此方法，并使用&lt;code&gt;quartz&lt;/code&gt;提供的&lt;code&gt;JobExecutionException&lt;/code&gt;控制异常后作业的声明周期。默认实现是直接将异常抛出。示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class XXXSimpleJob extends AbstractSimpleElasticJob {
    
    @Override
    public void process(final JobExecutionMultipleShardingContext context) {
        int zero = 0;
        10 / zero;
    }
    
    @Override
    public void handleJobExecutionException(JobExecutionException jobExecutionException) throws JobExecutionException {
        jobExecutionException.unscheduleAllTriggers();
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;任务监听配置:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;任务监听配置&lt;/h3&gt;

&lt;p&gt;可以通过配置多个任务监听器，在任务执行前和执行后执行监听的方法。监听器分为每台作业节点均执行和分布式场景中仅单一节点执行两种。&lt;/p&gt;

&lt;h4 id=&#34;每台作业节点均执行的监听:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;每台作业节点均执行的监听&lt;/h4&gt;

&lt;p&gt;若作业处理作业服务器的文件，处理完成后删除文件，可考虑使用每个节点均执行清理任务。此类型任务实现简单，且无需考虑全局分布式任务是否完成，请尽量使用此类型监听器。&lt;/p&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义监听器&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.dangdang.ddframe.job.api.JobExecutionMultipleShardingContext;
import com.dangdang.ddframe.job.api.listener.ElasticJobListener;

public class MyElasticJobListener implements AbstractDistributeOnceElasticJobListener {
    
    @Override
    public void beforeJobExecuted(final JobExecutionMultipleShardingContext shardingContext) {
        // do something ...
    }
    
    @Override
    public void afterJobExecuted(final JobExecutionMultipleShardingContext shardingContext) {
        // do something ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;将监听器作为参数传入&lt;code&gt;JobScheduler&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JobMain {
    
    public static void main(final String[] args) {
        new JobScheduler(regCenter, jobConfig, new MyElasticJobListener()).init();    
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;分布式场景中仅单一节点执行的监听:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;分布式场景中仅单一节点执行的监听&lt;/h4&gt;

&lt;p&gt;若作业处理数据库数据，处理完成后只需一个节点完成数据清理任务即可。此类型任务处理复杂，需同步分布式环境下作业的状态同步，提供了超时设置来避免作业不同步导致的死锁，请谨慎使用。&lt;/p&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义监听器&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.dangdang.ddframe.job.api.JobExecutionMultipleShardingContext;
import com.dangdang.ddframe.job.api.listener.AbstractDistributeOnceElasticJobListener;

public final class TestDistributeOnceElasticJobListener extends AbstractDistributeOnceElasticJobListener {
    
    public MyDistributeOnceElasticJobListener(final long startTimeoutMills, final long completeTimeoutMills) {
        super(startTimeoutMills, completeTimeoutMills);
    }
    
    @Override
    public void doBeforeJobExecutedAtLastStarted(final JobExecutionMultipleShardingContext shardingContext) {
        // do something ...
    }
    
    @Override
    public void doAfterJobExecutedAtLastCompleted(final JobExecutionMultipleShardingContext shardingContext) {
        // do something ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;将监听器作为参数传入&lt;code&gt;JobScheduler&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JobMain {

    public static void main(final String[] args) {
        long startTimeoutMills = 5000L;
        long completeTimeoutMills = 10000L;    
        new JobScheduler(regCenter, jobConfig, new MyDistributeOnceElasticJobListener(startTimeoutMills, completeTimeoutMills)).init();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;作业配置:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;作业配置&lt;/h2&gt;

&lt;p&gt;与&lt;code&gt;Spring&lt;/code&gt;容器配合使用作业，可以将作业&lt;code&gt;Bean&lt;/code&gt;配置为&lt;code&gt;Spring Bean&lt;/code&gt;，可在作业中通过依赖注入使用&lt;code&gt;Spring&lt;/code&gt;容器管理的数据源等对象。可用&lt;code&gt;placeholder&lt;/code&gt;占位符从属性文件中取值。&lt;/p&gt;

&lt;h3 id=&#34;spring命名空间配置:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;Spring命名空间配置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
    xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
    xmlns:reg=&amp;quot;http://www.dangdang.com/schema/ddframe/reg&amp;quot;
    xmlns:job=&amp;quot;http://www.dangdang.com/schema/ddframe/job&amp;quot;
    xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans 
                        http://www.springframework.org/schema/beans/spring-beans.xsd 
                        http://www.dangdang.com/schema/ddframe/reg 
                        http://www.dangdang.com/schema/ddframe/reg/reg.xsd 
                        http://www.dangdang.com/schema/ddframe/job 
                        http://www.dangdang.com/schema/ddframe/job/job.xsd 
                        &amp;quot;&amp;gt;
    &amp;lt;!--配置作业注册中心 --&amp;gt;
    &amp;lt;reg:zookeeper id=&amp;quot;regCenter&amp;quot; serverLists=&amp;quot; yourhost:2181&amp;quot; namespace=&amp;quot;dd-job&amp;quot; baseSleepTimeMilliseconds=&amp;quot;1000&amp;quot; maxSleepTimeMilliseconds=&amp;quot;3000&amp;quot; maxRetries=&amp;quot;3&amp;quot; /&amp;gt;
    
    &amp;lt;!-- 配置作业A--&amp;gt;
    &amp;lt;job:bean id=&amp;quot;simpleElasticJob&amp;quot; class=&amp;quot;xxx.MySimpleElasticJob&amp;quot; regCenter=&amp;quot;regCenter&amp;quot; cron=&amp;quot;0/10 * * * * ?&amp;quot;   shardingTotalCount=&amp;quot;3&amp;quot; shardingItemParameters=&amp;quot;0=A,1=B,2=C&amp;quot; /&amp;gt;
    
    &amp;lt;!-- 配置作业B--&amp;gt;
    &amp;lt;job:bean id=&amp;quot;throughputDataFlow&amp;quot; class=&amp;quot;xxx.MyThroughputDataFlowElasticJob&amp;quot; regCenter=&amp;quot;regCenter&amp;quot; cron=&amp;quot;0/10 * * * * ?&amp;quot; shardingTotalCount=&amp;quot;3&amp;quot; shardingItemParameters=&amp;quot;0=A,1=B,2=C&amp;quot; processCountIntervalSeconds=&amp;quot;10&amp;quot; concurrentDataProcessThreadCount=&amp;quot;10&amp;quot; /&amp;gt;
    
    &amp;lt;!-- 配置作业C--&amp;gt;
    &amp;lt;job:bean id=&amp;quot;listenerElasticJob&amp;quot; class=&amp;quot;xxx.MySimpleListenerElasticJob&amp;quot; regCenter=&amp;quot;regCenter&amp;quot; cron=&amp;quot;0/10 * * * * ?&amp;quot;   shardingTotalCount=&amp;quot;3&amp;quot; shardingItemParameters=&amp;quot;0=A,1=B,2=C&amp;quot;&amp;gt;
        &amp;lt;job:listener class=&amp;quot;xx.MySimpleJobListener&amp;quot;/&amp;gt;
        &amp;lt;job:listener class=&amp;quot;xx.MyOnceSimpleJobListener&amp;quot; startedTimeoutMilliseconds=&amp;quot;1000&amp;quot; completedTimeoutMilliseconds=&amp;quot;2000&amp;quot; /&amp;gt;
    &amp;lt;/job:bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;job-bean命名空间属性详细说明:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;job:bean命名空间属性详细说明&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性名&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;类型&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;是否必填&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;缺省值&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作业名称&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;class&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作业实现类，需实现&lt;code&gt;ElasticJob&lt;/code&gt;接口&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;regCenter&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;注册中心&lt;code&gt;Bean&lt;/code&gt;的引用，需引用&lt;code&gt;reg:zookeeper&lt;/code&gt;的声明&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cron&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;cron&lt;/code&gt;表达式，用于配置作业触发时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;shardingTotalCount&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作业分片总数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;shardingItemParameters&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;分片序列号和参数用等号分隔，多个键值对用逗号分隔&lt;br /&gt;分片序列号从&lt;code&gt;0&lt;/code&gt;开始，不可大于或等于作业分片总数&lt;br /&gt;如：&lt;br/&gt;&lt;code&gt;0=a,1=b,2=c&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;jobParameter&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作业自定义参数&lt;br /&gt;可以配置多个相同的作业，但是用不同的参数作为不同的调度实例&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;monitorExecution&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;true&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;监控作业运行时状态&lt;br /&gt;每次作业执行时间和间隔时间均非常短的情况，建议不监控作业运行时状态以提升效率。因为是瞬时状态，所以无必要监控。请用户自行增加数据堆积监控。并且不能保证数据重复选取，应在作业中实现幂等性。&lt;br /&gt;每次作业执行时间和间隔时间均较长的情况，建议监控作业运行时状态，可保证数据不会重复选取。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;monitorPort&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作业监控端口。&lt;br /&gt;建议配置作业监控端口, 方便开发者dump作业信息。&lt;br /&gt;使用方法: echo &amp;ldquo;dump&amp;rdquo; | nc 127.0.0.1 9888&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;processCountIntervalSeconds&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;300&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;统计作业处理数据数量的间隔时间&lt;br /&gt;单位：秒&lt;br /&gt;仅对&lt;code&gt;DataFlow&lt;/code&gt;类型作业有效&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;concurrentDataProcessThreadCount&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同时处理数据的并发线程数&lt;br /&gt;不能小于1&lt;br /&gt;仅&lt;code&gt;ThroughputDataFlow&lt;/code&gt;作业有效&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;fetchDataCount&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;每次抓取的数据量&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;maxTimeDiffSeconds&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;最大允许的本机与注册中心的时间误差秒数&lt;br /&gt;如果时间误差超过配置秒数则作业启动时将抛异常&lt;br /&gt;配置为&lt;code&gt;-1&lt;/code&gt;表示不校验时间误差&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;failover&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;false&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是否开启失效转移&lt;br /&gt;仅&lt;code&gt;monitorExecution&lt;/code&gt;开启，失效转移才有效&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;misfire&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;true&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是否开启错过任务重新执行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;jobShardingStrategyClass&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;true&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作业分片策略实现类全路径&lt;br /&gt;默认使用平均分配策略&lt;br /&gt;详情参见：&lt;a href=&#34;http://dangdangdotcom.github.io/elastic-job/post/job_strategy&#34;&gt;作业分片策略&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;description&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作业描述信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;disabled&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;false&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作业是否禁止启动&lt;br /&gt;可用于部署作业时，先禁止启动，部署结束后统一启动&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;overwrite&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;boolean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;false&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;本地配置是否可覆盖注册中心配置&lt;br /&gt;如果可覆盖，每次启动作业都以本地配置为准&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;job-listener命名空间属性详细说明:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;job:listener命名空间属性详细说明&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;job:listener&lt;/code&gt;必须配置为&lt;code&gt;job:bean&lt;/code&gt;的子元素&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性名&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;类型&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;是否必填&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;缺省值&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;class&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;前置后置任务监听实现类，需实现&lt;code&gt;ElasticJobListener&lt;/code&gt;接口&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;startedTimeoutMilliseconds&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;long&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Long.MAX_VALUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AbstractDistributeOnceElasticJobListener型监听器，最后一个作业执行前的执行方法的超时时间&lt;br /&gt;单位：毫秒&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;completedTimeoutMilliseconds&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;long&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Long.MAX_VALUE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AbstractDistributeOnceElasticJobListener型监听器，最后一个作业执行后的执行方法的超时时间&lt;br /&gt;单位：毫秒&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;reg-bean命名空间属性详细说明:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;reg:bean命名空间属性详细说明&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性名&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;类型&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;是否必填&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;缺省值&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;注册中心在&lt;code&gt;Spring&lt;/code&gt;容器中的主键&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;serverLists&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;连接&lt;code&gt;Zookeeper&lt;/code&gt;服务器的列表&lt;br /&gt;包括IP地址和端口号&lt;br /&gt;多个地址用逗号分隔&lt;br /&gt;如: host1:2181,host2:2181&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;namespace&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;Zookeeper&lt;/code&gt;的命名空间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;baseSleepTimeMilliseconds&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;等待重试的间隔时间的初始值&lt;br /&gt;单位：毫秒&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;maxSleepTimeMilliseconds&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;等待重试的间隔时间的最大值&lt;br /&gt;单位：毫秒&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;maxRetries&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;最大重试次数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;sessionTimeoutMilliseconds&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;60000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;会话超时时间&lt;br /&gt;单位：毫秒&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;connectionTimeoutMilliseconds&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;15000&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;连接超时时间&lt;br /&gt;单位：毫秒&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;digest&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;无验证&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;连接&lt;code&gt;Zookeeper&lt;/code&gt;的权限令牌&lt;br /&gt;缺省为不需要权限验证&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;nestedPort&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;内嵌&lt;code&gt;Zookeeper&lt;/code&gt;的端口号&lt;br /&gt;-1表示不开启内嵌&lt;code&gt;Zookeeper&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;nestedDataDir&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;内嵌&lt;code&gt;Zookeeper&lt;/code&gt;的数据存储路径&lt;br /&gt;为空表示不开启内嵌&lt;code&gt;Zookeeper&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;基于spring但不使用命名空间:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;基于Spring但不使用命名空间&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;    &amp;lt;!-- 配置作业注册中心 --&amp;gt;
    &amp;lt;bean id=&amp;quot;regCenter&amp;quot; class=&amp;quot;com.dangdang.ddframe.reg.zookeeper.ZookeeperRegistryCenter&amp;quot; init-method=&amp;quot;init&amp;quot;&amp;gt;
        &amp;lt;constructor-arg&amp;gt;
            &amp;lt;bean class=&amp;quot;com.dangdang.ddframe.reg.zookeeper.ZookeeperConfiguration&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;serverLists&amp;quot; value=&amp;quot;${xxx}&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;namespace&amp;quot; value=&amp;quot;${xxx}&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;baseSleepTimeMilliseconds&amp;quot; value=&amp;quot;${xxx}&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;maxSleepTimeMilliseconds&amp;quot; value=&amp;quot;${xxx}&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;maxRetries&amp;quot; value=&amp;quot;${xxx}&amp;quot; /&amp;gt;
            &amp;lt;/bean&amp;gt;
        &amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 配置作业--&amp;gt;
    &amp;lt;bean id=&amp;quot;xxxJob&amp;quot; class=&amp;quot;com.dangdang.ddframe.job.api.JobScheduler&amp;quot; init-method=&amp;quot;init&amp;quot;&amp;gt;
        &amp;lt;constructor-arg ref=&amp;quot;regCenter&amp;quot; /&amp;gt;
        &amp;lt;constructor-arg&amp;gt;
            &amp;lt;bean class=&amp;quot;com.dangdang.ddframe.job.api.JobConfiguration&amp;quot;&amp;gt;
                &amp;lt;constructor-arg name=&amp;quot;jobName&amp;quot; value=&amp;quot;xxxJob&amp;quot; /&amp;gt;
                &amp;lt;constructor-arg name=&amp;quot;jobClass&amp;quot; value=&amp;quot;xxxDemoJob&amp;quot; /&amp;gt;
                &amp;lt;constructor-arg name=&amp;quot;shardingTotalCount&amp;quot; value=&amp;quot;10&amp;quot; /&amp;gt;
                &amp;lt;constructor-arg name=&amp;quot;cron&amp;quot; value=&amp;quot;0/10 * * * * ?&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;shardingItemParameters&amp;quot; value=&amp;quot;${xxx}&amp;quot; /&amp;gt;
            &amp;lt;/bean&amp;gt;
        &amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;不使用spring配置:74c632aa9613b8dd6b95bfab1ba313e2&#34;&gt;不使用Spring配置&lt;/h3&gt;

&lt;p&gt;如果不使用Spring框架，可以用如下方式启动作业。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.dangdang.ddframe.job.api.JobConfiguration;
import com.dangdang.ddframe.job.api.JobScheduler;
import com.dangdang.ddframe.reg.base.CoordinatorRegistryCenter;
import com.dangdang.ddframe.reg.zookeeper.ZookeeperConfiguration;
import com.dangdang.ddframe.reg.zookeeper.ZookeeperRegistryCenter;
import com.dangdang.example.elasticjob.core.job.SimpleJobDemo;
import com.dangdang.example.elasticjob.core.job.ThroughputDataFlowJobDemo;
import com.dangdang.example.elasticjob.core.job.SequenceDataFlowJobDemo;

public class JobDemo {
    
    // 定义Zookeeper注册中心配置对象
    private ZookeeperConfiguration zkConfig = new ZookeeperConfiguration(&amp;quot;localhost:2181&amp;quot;, &amp;quot;elastic-job-example&amp;quot;, 1000, 3000, 3);
    
    // 定义Zookeeper注册中心
    private CoordinatorRegistryCenter regCenter = new ZookeeperRegistryCenter(zkConfig);
    
    // 定义作业1配置对象
    private JobConfiguration jobConfig1 = new JobConfiguration(&amp;quot;simpleJob&amp;quot;, SimpleJobDemo.class, 10, &amp;quot;0/5 * * * * ?&amp;quot;);
    
    // 定义作业2配置对象
    private JobConfiguration jobConfig2 = new JobConfiguration(&amp;quot;throughputDataFlowJob&amp;quot;, ThroughputDataFlowJobDemo.class, 10, &amp;quot;0/5 * * * * ?&amp;quot;);
    
    // 定义作业3配置对象
    private JobConfiguration jobConfig3 = new JobConfiguration(&amp;quot;sequenceDataFlowJob&amp;quot;, SequenceDataFlowJobDemo.class, 10, &amp;quot;0/5 * * * * ?&amp;quot;);
    
    public static void main(final String[] args) {
        new JobDemo().init();
    }
    
    private void init() {
        // 连接注册中心
        regCenter.init();
        // 启动作业1
        new JobScheduler(regCenter, jobConfig1).init();
        // 启动作业2
        new JobScheduler(regCenter, jobConfig2).init();
        // 启动作业3
        new JobScheduler(regCenter, jobConfig3).init();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>使用限制</title>
      <link>http://dangdangdotcom.github.io/elastic-job/post/limitations/</link>
      <pubDate>Wed, 27 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/elastic-job/post/limitations/</guid>
      <description>

&lt;h1 id=&#34;使用限制:187f2cad6c4cc3b3972d4d058186f234&#34;&gt;使用限制&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;作业一旦启动成功后不能修改作业名称，如果修改名称则视为新的作业。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同一台作业服务器只能运行一个相同的作业实例，因为作业运行时是按照&lt;code&gt;IP&lt;/code&gt;注册和管理的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一旦有服务器波动，或者修改分片项，将会触发重新分片；触发重新分片将会导致运行中的流式处理的作业在执行完本次作业后不再继续执行，等待分片结束后再恢复正常。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开启&lt;code&gt;monitorExecution&lt;/code&gt;才能实现分布式作业幂等性（即不会在多个作业服务器运行同一个分片）的功能，但&lt;code&gt;monitorExecution&lt;/code&gt;对短时间内执行的作业（如每5秒一触发）性能影响较大，建议关闭并自行实现幂等性。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;elastic-job&lt;/code&gt;没有自动删除作业服务器的功能，因为无法区分是服务器崩溃还是正常下线。所以如果要下线服务器，需要手工删除&lt;code&gt;zookeeper&lt;/code&gt;中相关的服务器节点。由于直接删除服务器节点风险较大，暂时不考虑在运维平台增加此功能。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>运维平台</title>
      <link>http://dangdangdotcom.github.io/elastic-job/post/web_console/</link>
      <pubDate>Wed, 27 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/elastic-job/post/web_console/</guid>
      <description>

&lt;h1 id=&#34;运维平台:8e6e8878ca7d415631798f7cc4fcd04e&#34;&gt;运维平台&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;elastic-job&lt;/code&gt;运维平台以&lt;code&gt;war&lt;/code&gt;包形式提供，可自行部署到&lt;code&gt;tomcat&lt;/code&gt;或&lt;code&gt;jetty&lt;/code&gt;等支持&lt;code&gt;servlet&lt;/code&gt;的&lt;code&gt;web&lt;/code&gt;容器中。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;elastic-job-console.war&lt;/code&gt;可以通过编译源码或从&lt;code&gt;maven&lt;/code&gt;中央仓库获取。&lt;/p&gt;

&lt;h2 id=&#34;登录:8e6e8878ca7d415631798f7cc4fcd04e&#34;&gt;登录&lt;/h2&gt;

&lt;p&gt;默认用户名和密码是&lt;code&gt;root/root&lt;/code&gt;，可以通过修改&lt;code&gt;conf\auth.properties&lt;/code&gt;文件修改默认登录用户名和密码。&lt;/p&gt;

&lt;h2 id=&#34;主要功能:8e6e8878ca7d415631798f7cc4fcd04e&#34;&gt;主要功能&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;登录安全控制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注册中心管理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;作业维度状态查看&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;服务器维度状态查看&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;快捷修改作业设置&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;控制作业暂停和恢复运行&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;设计理念:8e6e8878ca7d415631798f7cc4fcd04e&#34;&gt;设计理念&lt;/h2&gt;

&lt;p&gt;运维平台和&lt;code&gt;elastic-job&lt;/code&gt;并无直接关系，是通过读取作业注册中心数据展现作业状态，或更新注册中心数据修改全局配置。&lt;/p&gt;

&lt;p&gt;控制台只能控制作业本身是否运行，但不能控制作业进程的启停，因为控制台和作业本身服务器是完全分布式的，控制台并不能控制作业服务器。&lt;/p&gt;

&lt;h2 id=&#34;不支持项:8e6e8878ca7d415631798f7cc4fcd04e&#34;&gt;不支持项&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;添加作业。因为作业都是在首次运行时自动添加，使用运维平台添加作业并无必要。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;停止作业。即使删除了&lt;code&gt;Zookeeper&lt;/code&gt;信息也不能真正停止作业的运行，还会导致运行中的作业出问题。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除作业服务器。由于直接删除服务器节点风险较大，暂时不考虑在运维平台增加此功能。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;主要界面:8e6e8878ca7d415631798f7cc4fcd04e&#34;&gt;主要界面&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;总览页&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../../img/console_index.png&#34; alt=&#34;总览页&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;注册中心管理页&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../../img/console_reg_center.png&#34; alt=&#34;注册中心管理页&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;作业详细信息页&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../../img/console_job_details.png&#34; alt=&#34;作业详细信息页&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务器详细信息页&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../../img/console_server_details.png&#34; alt=&#34;服务器详细信息页&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>阅读源码编译问题说明</title>
      <link>http://dangdangdotcom.github.io/elastic-job/post/source_code_guide/</link>
      <pubDate>Wed, 27 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/elastic-job/post/source_code_guide/</guid>
      <description>

&lt;h1 id=&#34;阅读源码编译问题说明:d199b0c27969964f019cc11c23305af5&#34;&gt;阅读源码编译问题说明&lt;/h1&gt;

&lt;p&gt;因为关注极简代码，&lt;code&gt;Elastic-Job&lt;/code&gt;使用&lt;code&gt;lombok&lt;/code&gt;。在阅读源码的过程中会遇到&lt;code&gt;@Getter, @Setter&lt;/code&gt;等注解导致不能编译，请按照以下步骤安装&lt;code&gt;lombok&lt;/code&gt;到你的&lt;code&gt;IDE&lt;/code&gt;，只使用发布包请不用关注。&lt;/p&gt;

&lt;h2 id=&#34;lombok安装指南:d199b0c27969964f019cc11c23305af5&#34;&gt;lombok安装指南&lt;/h2&gt;

&lt;h3 id=&#34;eclipse:d199b0c27969964f019cc11c23305af5&#34;&gt;Eclipse&lt;/h3&gt;

&lt;p&gt;首先配置好&lt;code&gt;Eclipse&lt;/code&gt;环境，然后双击打开&lt;a href=&#34;https://projectlombok.org/downloads/lombok.jar&#34;&gt;lombok.jar&lt;/a&gt;文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/lombok-eclipse.jpg&#34; alt=&#34;lombok-eclipse&#34; /&gt;&lt;/p&gt;

&lt;p&gt;确认&lt;code&gt;Eclipse&lt;/code&gt;的安装路径，点击&lt;code&gt;install/update&lt;/code&gt;按钮，即可完成安装，最后需要重启&lt;code&gt;Eclipse&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;** 如何确认安装成功？**&lt;/p&gt;

&lt;p&gt;确认&lt;code&gt;Eclipse&lt;/code&gt;安装路径下有&lt;code&gt;lombok.jar&lt;/code&gt;包，并且配置文件&lt;code&gt;eclipse.ini&lt;/code&gt;中是否已添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-javaagent:lombok.jar
-Xbootclasspath/a:lombok.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;否则请自行将缺少的部分添加到相应的位置即可。&lt;/p&gt;

&lt;p&gt;安装完成后可直接使用元注解简化你的POJO。如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/lombok-pojo.jpg&#34; alt=&#34;lombok-pojo&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;其它ide:d199b0c27969964f019cc11c23305af5&#34;&gt;其它IDE&lt;/h3&gt;

&lt;p&gt;请参照&lt;a href=&#34;https://projectlombok.org/download.html&#34;&gt;&lt;code&gt;lombok&lt;/code&gt;官方&lt;/a&gt;提供的解决方案。
&lt;code&gt;Lombok&lt;/code&gt;还可以提供很多其他功能，如&lt;code&gt;log&lt;/code&gt;变量自动生成等，可参阅&lt;code&gt;lombok&lt;/code&gt;官网。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>实现原理</title>
      <link>http://dangdangdotcom.github.io/elastic-job/post/theory/</link>
      <pubDate>Thu, 28 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/elastic-job/post/theory/</guid>
      <description>

&lt;h1 id=&#34;实现原理:fb5f6163b017699129804288aa91c39e&#34;&gt;实现原理&lt;/h1&gt;

&lt;h2 id=&#34;弹性分布式实现:fb5f6163b017699129804288aa91c39e&#34;&gt;弹性分布式实现&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一台服务器上线触发主服务器选举。主服务器一旦下线，则重新触发选举，选举过程中阻塞，只有主服务器选举完成，才会执行其他任务。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;某作业服务器上线时会自动将服务器信息注册到注册中心，下线时会自动更新服务器状态。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;主节点选举，服务器上下线，分片总数变更均更新重新分片标记。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定时任务触发时，如需重新分片，则通过主服务器分片，分片过程中阻塞，分片结束后才可执行任务。如分片过程中主服务器下线，则先选举主服务器，再分片。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过上一项说明可知，为了维持作业运行时的稳定性，运行过程中只会标记分片状态，不会重新分片。分片仅可能发生在下次任务触发前。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每次分片都会按服务器&lt;code&gt;IP&lt;/code&gt;排序，保证分片结果不会产生较大波动。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实现失效转移功能，在某台服务器执行完毕后主动抓取未分配的分片，并且在某台服务器下线后主动寻找可用的服务器执行任务。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;注册中心数据结构:fb5f6163b017699129804288aa91c39e&#34;&gt;注册中心数据结构&lt;/h2&gt;

&lt;p&gt;注册中心在定义的命名空间下，创建作业名称节点，用于区分不同作业，所以作业一旦创建则不能修改作业名称，如果修改名称将视为新的作业。作业名称节点下又包含4个数据子节点，分别是&lt;code&gt;config&lt;/code&gt;, &lt;code&gt;servers&lt;/code&gt;, &lt;code&gt;execution&lt;/code&gt;和&lt;code&gt;leader&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;概览:fb5f6163b017699129804288aa91c39e&#34;&gt;概览&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;../../img/reg_center.jpg&#34; alt=&#34;注册中心数据结构&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;config节点:fb5f6163b017699129804288aa91c39e&#34;&gt;config节点&lt;/h3&gt;

&lt;p&gt;作业全局配置信息&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;子节点名&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;临时节点&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;jobClass&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作业实现类名称&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;shardingTotalCount&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作业分片总数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cron&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作业启动时间的&lt;code&gt;cron&lt;/code&gt;表达式&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;shardingItemParameters&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;分片序列号和个性化参数对照表&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;jobParameter&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作业自定义参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;monitorExecution&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;监控作业执行时状态&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;processCountIntervalSeconds&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;统计作业处理数据数量的间隔时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;concurrentDataProcessThreadCount&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;同时处理数据的并发线程数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;fetchDataCount&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;每次抓取的数据量&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;maxTimeDiffSeconds&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;允许的本机与注册中心的时间误差秒数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;failover&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是否开启失效转移&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;misfire&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是否开启错过任务重新执行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;description&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作业描述信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;servers节点:fb5f6163b017699129804288aa91c39e&#34;&gt;servers节点&lt;/h3&gt;

&lt;p&gt;作业服务器信息，子节点是作业服务器的&lt;code&gt;IP&lt;/code&gt;地址。&lt;code&gt;IP&lt;/code&gt;地址节点的子节点存储详细信息。同一台作业服务器只能运行一个相同的作业实例，因为作业运行时是按照&lt;code&gt;IP&lt;/code&gt;注册和管理的。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;子节点名&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;临时节点&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;hostName&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作业服务器名称&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;status&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作业服务器状态，分为READY和RUNNING&lt;br /&gt;用于表示服务器在等待执行作业还是正在执行作业&lt;br /&gt;如果status节点不存在则表示作业服务器未上线&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;disabled&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;作业服务器状态是否禁用&lt;br /&gt;可用于部署作业时，先禁止启动，部署结束后统一启动&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;sharding&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;该作业服务器分到的作业分片项&lt;br /&gt;多个分片项用逗号分隔&lt;br /&gt;如：&lt;code&gt;0, 1, 2&lt;/code&gt;代表该服务器执行第&lt;code&gt;1, 2, 3&lt;/code&gt;片分片&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;processSuccessCount&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;统计一段时间内处理数据成功的数量&lt;br /&gt;统计间隔可通过&lt;code&gt;config\processCountIntervalSeconds&lt;/code&gt;配置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;processFailureCount&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;统计一段时间内处理数据失败的数量&lt;br /&gt;统计间隔可通过&lt;code&gt;config\processCountIntervalSeconds&lt;/code&gt;配置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;stoped&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;停止作业的标记&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;execution节点:fb5f6163b017699129804288aa91c39e&#34;&gt;execution节点&lt;/h3&gt;

&lt;p&gt;执行时信息，子节点是分片项序号，从零开始，至分片总数减一。分片项序号的子节点存储详细信息。可通过配置&lt;code&gt;config\monitorExecution&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;关闭记录作业执行时信息。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;子节点名&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;临时节点&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;running&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;分片项正在运行的状态&lt;br /&gt;如果没有此节点，并且没有&lt;code&gt;completed&lt;/code&gt;节点，表示该分片未运行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;completed&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;分片项运行完成的状态&lt;br /&gt;下次作业开始执行时会清理&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;failover&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;如果该分片项被失效转移分配给其他作业服务器，则此节点值记录执行此分片的作业服务器&lt;code&gt;IP&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;lastBeginTime&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;该分片项最近一次的开始执行时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;nextFireTime&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;该分片项下次作业触发时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;lastCompleteTime&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;该分片项最近一次的结束执行时间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;leader节点:fb5f6163b017699129804288aa91c39e&#34;&gt;leader节点&lt;/h3&gt;

&lt;p&gt;作业服务器主节点信息，分为&lt;code&gt;election&lt;/code&gt;，&lt;code&gt;sharding&lt;/code&gt;和&lt;code&gt;execution&lt;/code&gt;三个子节点。分别用于主节点选举，分片和作业执行时处理。&lt;/p&gt;

&lt;p&gt;leader节点是内部使用的节点，如果对作业框架原理不感兴趣，可不关注此节点。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;子节点名&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;临时节点&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;election\host&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;主节点服务器&lt;code&gt;IP&lt;/code&gt;地址&lt;br /&gt;一旦该节点被删除将会触发重新选举&lt;br /&gt;重新选举的过程中一切主节点相关的操作都将阻塞&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;election\latch&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;主节点选举的分布式锁&lt;br /&gt;为&lt;code&gt;curator&lt;/code&gt;的分布式锁使用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;sharding\necessary&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是否需要重新分片的标记&lt;br /&gt;如果分片总数变化，或作业服务器节点上下线或启用/禁用，以及主节点选举，会触发设置重分片标记&lt;br /&gt;作业在下次执行时使用主节点重新分片，且中间不会被打断&lt;br /&gt;作业执行时不会触发分片&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;sharding\processing&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;主节点在分片时持有的节点&lt;br /&gt;如果有此节点，所有的作业执行都将阻塞，直至分片结束&lt;br /&gt;主节点分片结束或主节点崩溃会删除此临时节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;execution\necessary&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是否需要修正作业执行时分片项信息的标记&lt;br /&gt;如果分片总数变化，会触发设置修正分片项信息标记&lt;br /&gt;作业在下次执行时会增加或减少分片项数量&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;execution\cleaning&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;是&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;主节点在清理上次作业运行时状态时所持有的节点&lt;br /&gt;每次开始新作业都需要清理上次运行完成的作业信息&lt;br /&gt;如果有此节点，所有的作业执行都将阻塞，直至清理结束&lt;br /&gt;主节点分片结束或主节点崩溃会删除此临时节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;failover\items\分片项&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;一旦有作业崩溃，则会向此节点记录&lt;br /&gt;当有空闲作业服务器时，会从此节点抓取需失效转移的作业项&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;failover\items\latch&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;分配失效转移分片项时占用的分布式锁&lt;br /&gt;为&lt;code&gt;curator&lt;/code&gt;的分布式锁使用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;流程图:fb5f6163b017699129804288aa91c39e&#34;&gt;流程图&lt;/h2&gt;

&lt;h3 id=&#34;作业启动:fb5f6163b017699129804288aa91c39e&#34;&gt;作业启动&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;../../img/job_start.jpg&#34; alt=&#34;作业启动&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;作业执行:fb5f6163b017699129804288aa91c39e&#34;&gt;作业执行&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;../../img/job_exec.jpg&#34; alt=&#34;作业执行&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>作业分片策略</title>
      <link>http://dangdangdotcom.github.io/elastic-job/post/job_strategy/</link>
      <pubDate>Wed, 27 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/elastic-job/post/job_strategy/</guid>
      <description>

&lt;h1 id=&#34;作业分片策略:ab6c830101f9131fda2927705be73818&#34;&gt;作业分片策略&lt;/h1&gt;

&lt;h2 id=&#34;框架提供的分片策略:ab6c830101f9131fda2927705be73818&#34;&gt;框架提供的分片策略&lt;/h2&gt;

&lt;h3 id=&#34;averageallocationjobshardingstrategy:ab6c830101f9131fda2927705be73818&#34;&gt;AverageAllocationJobShardingStrategy&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;全路径：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;com.dangdang.ddframe.job.plugin.sharding.strategy.AverageAllocationJobShardingStrategy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;策略说明：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基于平均分配算法的分片策略，也是默认的分片策略。&lt;/p&gt;

&lt;p&gt;如果分片不能整除，则不能整除的多余分片将依次追加到序号小的服务器。如：&lt;/p&gt;

&lt;p&gt;如果有&lt;code&gt;3&lt;/code&gt;台服务器，分成&lt;code&gt;9&lt;/code&gt;片，则每台服务器分到的分片是：&lt;code&gt;1=[0,1,2], 2=[3,4,5], 3=[6,7,8]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果有&lt;code&gt;3&lt;/code&gt;台服务器，分成&lt;code&gt;8&lt;/code&gt;片，则每台服务器分到的分片是：&lt;code&gt;1=[0,1,6], 2=[2,3,7], 3=[4,5]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果有&lt;code&gt;3&lt;/code&gt;台服务器，分成&lt;code&gt;10&lt;/code&gt;片，则每台服务器分到的分片是：&lt;code&gt;1=[0,1,2,9], 2=[3,4,5], 3=[6,7,8]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;odevitysortbynamejobshardingstrategy:ab6c830101f9131fda2927705be73818&#34;&gt;OdevitySortByNameJobShardingStrategy&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;全路径：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;com.dangdang.ddframe.job.plugin.sharding.strategy.OdevitySortByNameJobShardingStrategy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;策略说明：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据作业名的哈希值奇偶数决定&lt;code&gt;IP&lt;/code&gt;升降序算法的分片策略。&lt;/p&gt;

&lt;p&gt;作业名的哈希值为奇数则&lt;code&gt;IP&lt;/code&gt;升序。&lt;/p&gt;

&lt;p&gt;作业名的哈希值为偶数则&lt;code&gt;IP&lt;/code&gt;降序。&lt;/p&gt;

&lt;p&gt;用于不同的作业平均分配负载至不同的服务器。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AverageAllocationJobShardingStrategy&lt;/code&gt;的缺点是，一旦分片数小于作业服务器数，作业将永远分配至&lt;code&gt;IP&lt;/code&gt;地址靠前的服务器，导致&lt;code&gt;IP&lt;/code&gt;地址靠后的服务器空闲。而&lt;code&gt;OdevitySortByNameJobShardingStrategy&lt;/code&gt;则可以根据作业名称重新分配服务器负载。如：&lt;/p&gt;

&lt;p&gt;如果有&lt;code&gt;3&lt;/code&gt;台服务器，分成&lt;code&gt;2&lt;/code&gt;片，作业名称的哈希值为奇数，则每台服务器分到的分片是：&lt;code&gt;1=[0], 2=[1], 3=[]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果有&lt;code&gt;3&lt;/code&gt;台服务器，分成&lt;code&gt;2&lt;/code&gt;片，作业名称的哈希值为偶数，则每台服务器分到的分片是：&lt;code&gt;3=[0], 2=[1], 1=[]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;rotateserverbynamejobshardingstrategy:ab6c830101f9131fda2927705be73818&#34;&gt;RotateServerByNameJobShardingStrategy&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;全路径：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;com.dangdang.ddframe.job.plugin.sharding.strategy.RotateServerByNameJobShardingStrategy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;策略说明：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据作业名的哈希值对服务器列表进行轮转的分片策略。&lt;/p&gt;

&lt;h2 id=&#34;自定义分片策略:ab6c830101f9131fda2927705be73818&#34;&gt;自定义分片策略&lt;/h2&gt;

&lt;p&gt;实现&lt;code&gt;JobShardingStrategy&lt;/code&gt;接口并实现&lt;code&gt;sharding&lt;/code&gt;方法，接口方法参数为作业服务器&lt;code&gt;IP&lt;/code&gt;列表和分片策略选项，分片策略选项包括作业名称，分片总数以及分片序列号和个性化参数对照表，可以根据需求定制化自己的分片策略。&lt;/p&gt;

&lt;p&gt;欢迎将分片策略以插件的形式贡献至&lt;code&gt;com.dangdang.ddframe.job.plugin.sharding.strategy&lt;/code&gt;包。&lt;/p&gt;

&lt;h2 id=&#34;配置分片策略:ab6c830101f9131fda2927705be73818&#34;&gt;配置分片策略&lt;/h2&gt;

&lt;p&gt;与配置通常的作业属性相同，在&lt;code&gt;spring&lt;/code&gt;命名空间或者&lt;code&gt;JobConfiguration&lt;/code&gt;中配置&lt;code&gt;jobShardingStrategyClass&lt;/code&gt;属性，属性值是作业分片策略类的全路径。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>作业运行状态监控</title>
      <link>http://dangdangdotcom.github.io/elastic-job/post/execution_monitor/</link>
      <pubDate>Wed, 27 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/elastic-job/post/execution_monitor/</guid>
      <description>

&lt;h1 id=&#34;作业运行状态监控:1a9088410a73144a71b8e568d5b668d1&#34;&gt;作业运行状态监控&lt;/h1&gt;

&lt;p&gt;通过监听&lt;code&gt;elastic-job&lt;/code&gt;的&lt;code&gt;zookeeper&lt;/code&gt;注册中心的几个关键节点即可完成作业运行状态监控功能。&lt;/p&gt;

&lt;h2 id=&#34;监听作业服务器存活:1a9088410a73144a71b8e568d5b668d1&#34;&gt;监听作业服务器存活&lt;/h2&gt;

&lt;p&gt;监听&lt;code&gt;job_name\servers\ip_address\status&lt;/code&gt;节点是否存在。该节点为临时节点，如果作业服务器下线，该节点将删除。&lt;/p&gt;

&lt;h2 id=&#34;监听近期数据处理成功:1a9088410a73144a71b8e568d5b668d1&#34;&gt;监听近期数据处理成功&lt;/h2&gt;

&lt;p&gt;数据流类型作业，可通过监听近期数据处理成功数判断作业流量是否正常。&lt;/p&gt;

&lt;p&gt;监听&lt;code&gt;job_name\servers\ip_address\processSuccessCount&lt;/code&gt;节点的值。如果小于作业正常处理的阀值，可选择报警。&lt;/p&gt;

&lt;h2 id=&#34;监听近期数据处理失败:1a9088410a73144a71b8e568d5b668d1&#34;&gt;监听近期数据处理失败&lt;/h2&gt;

&lt;p&gt;数据流类型作业，可通过监听近期数据处理失败数判断作业处理结果。&lt;/p&gt;

&lt;p&gt;监听&lt;code&gt;job_name\servers\ip_address\processFailureCount&lt;/code&gt;节点的值。如果大于&lt;code&gt;0&lt;/code&gt;，可选择报警。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>dump作业运行信息（便于开发者debug）</title>
      <link>http://dangdangdotcom.github.io/elastic-job/post/dump/</link>
      <pubDate>Wed, 27 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/elastic-job/post/dump/</guid>
      <description>

&lt;h1 id=&#34;dump作业运行信息-便于开发者debug:f69c5aba1a4f7d968cfc659d3581c29a&#34;&gt;dump作业运行信息（便于开发者debug）&lt;/h1&gt;

&lt;p&gt;由于在使用&lt;code&gt;elastic-job&lt;/code&gt;中可能会碰到一些分布式问题，导致作业运行不稳定。由于无法在生产环境调试，通过&lt;code&gt;dump&lt;/code&gt;命令可以把作业内部相关信息&lt;code&gt;dump&lt;/code&gt;出来，方便开发者&lt;code&gt;debug&lt;/code&gt;分析；另外为了不泄露隐私，已经把相关信息中的&lt;code&gt;ip&lt;/code&gt;地址以&lt;code&gt;ip1, ip2...&lt;/code&gt;的形式过滤掉了，可以在互联网上公开传输环境信息，便于进一步完善&lt;code&gt;elastic-job&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;如何使用:f69c5aba1a4f7d968cfc659d3581c29a&#34;&gt;如何使用&lt;/h2&gt;

&lt;h3 id=&#34;配置监听端口:f69c5aba1a4f7d968cfc659d3581c29a&#34;&gt;配置监听端口&lt;/h3&gt;

&lt;p&gt;支持两种配置方式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Spring方式&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
    xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
    xmlns:reg=&amp;quot;http://www.dangdang.com/schema/ddframe/reg&amp;quot;
    xmlns:job=&amp;quot;http://www.dangdang.com/schema/ddframe/job&amp;quot;
    xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans 
                        http://www.springframework.org/schema/beans/spring-beans.xsd 
                        http://www.dangdang.com/schema/ddframe/reg 
                        http://www.dangdang.com/schema/ddframe/reg/reg.xsd 
                        http://www.dangdang.com/schema/ddframe/job 
                        http://www.dangdang.com/schema/ddframe/job/job.xsd 
                        &amp;quot;&amp;gt;
    &amp;lt;!--配置作业注册中心 --&amp;gt;
    &amp;lt;reg:zookeeper id=&amp;quot;regCenter&amp;quot; serverLists=&amp;quot; yourhost:2181&amp;quot; namespace=&amp;quot;dd-job&amp;quot; baseSleepTimeMilliseconds=&amp;quot;1000&amp;quot; maxSleepTimeMilliseconds=&amp;quot;3000&amp;quot; maxRetries=&amp;quot;3&amp;quot; /&amp;gt;
    
    &amp;lt;!-- 配置作业--&amp;gt;
    &amp;lt;job:bean id=&amp;quot;oneOffElasticJob&amp;quot; monitorPort=&amp;quot;9888&amp;quot; class=&amp;quot;xxx.MyElasticJob&amp;quot; regCenter=&amp;quot;regCenter&amp;quot; cron=&amp;quot;0/10 * * * * ?&amp;quot;   shardingTotalCount=&amp;quot;3&amp;quot; shardingItemParameters=&amp;quot;0=A,1=B,2=C&amp;quot; /&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Java方式&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JobMain {
    public static void main(final String[] args) {
        JobConfiguration jobConfig = new JobConfiguration(&amp;quot;simpleElasticDemoJob&amp;quot;, SimpleJobDemo.class, 10, &amp;quot;0/5 * * * * ?&amp;quot;);
        jobConfig.setMonitorPort(9888);
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;启动作业:f69c5aba1a4f7d968cfc659d3581c29a&#34;&gt;启动作业&lt;/h3&gt;

&lt;h3 id=&#34;执行dump命令:f69c5aba1a4f7d968cfc659d3581c29a&#34;&gt;执行dump命令&lt;/h3&gt;

&lt;p&gt;dump命令完全参照Zookeeper的四字命令的理念&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &amp;quot;dump&amp;quot; | nc &amp;lt;任意一台作业服务器IP&amp;gt; 9888
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;../../img/dump.jpg&#34; alt=&#34;dump命令&#34; /&gt;&lt;/p&gt;

&lt;p&gt;导出到文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &amp;quot;dump&amp;quot; | nc &amp;lt;任意一台作业服务器IP&amp;gt; 9888 &amp;gt; job_debug.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用注意事项:f69c5aba1a4f7d968cfc659d3581c29a&#34;&gt;使用注意事项&lt;/h2&gt;

&lt;p&gt;务必更新到&lt;code&gt;1.0.3-snapshot&lt;/code&gt;最新或其后续版本&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>快速上手</title>
      <link>http://dangdangdotcom.github.io/elastic-job/post/quick_start/</link>
      <pubDate>Wed, 27 Jan 2016 16:14:21 +0800</pubDate>
      
      <guid>http://dangdangdotcom.github.io/elastic-job/post/quick_start/</guid>
      <description>

&lt;h1 id=&#34;快速上手:1370e1c2bb52dcdda68d1c916daa26e4&#34;&gt;快速上手&lt;/h1&gt;

&lt;h2 id=&#34;下载源码和文档:1370e1c2bb52dcdda68d1c916daa26e4&#34;&gt;下载源码和文档&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/dangdangdotcom/elastic-job&#34;&gt;https://github.com/dangdangdotcom/elastic-job&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/quick_start_01.png&#34; alt=&#34;quick_start_01&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/quick_start_02.png&#34; alt=&#34;quick_start_02&#34; /&gt;&lt;/p&gt;

&lt;p&gt;选择 &lt;code&gt;tags\1.0.2&lt;/code&gt; 作为源码&lt;/p&gt;

&lt;p&gt;其中，需要用&lt;code&gt;elastic-job-example&lt;/code&gt;来做应用例子，自行安装&lt;code&gt;Zookeeper&lt;/code&gt;来做注册中心。&lt;/p&gt;

&lt;h2 id=&#34;安装lombok:1370e1c2bb52dcdda68d1c916daa26e4&#34;&gt;安装lombok&lt;/h2&gt;

&lt;p&gt;开发代码省略了 set get log等，需要安装此包才不会报错。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lombok&lt;/code&gt;的官方网址：&lt;a href=&#34;http://projectlombok.org/&#34;&gt;http://projectlombok.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;lombok安装&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;lombok&lt;/code&gt;是需要安装的，如果不安装，&lt;code&gt;IDE&lt;/code&gt;则无法解析&lt;code&gt;lombok&lt;/code&gt;注解。先在官网下载最新版本的&lt;code&gt;JAR&lt;/code&gt;包，现在是&lt;code&gt;0.11.2&lt;/code&gt;版本，我用的是&lt;code&gt;0.11.0&lt;/code&gt;。第一次使用的时候我下载的是最新版本的，也就是我现在用的&lt;code&gt;0.11.0&lt;/code&gt;，到现在已经更新了两个版本，更新的好快啊……&lt;/p&gt;

&lt;p&gt;可以用以下两种方式安装：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;双击下载下来的&lt;code&gt;JAR&lt;/code&gt;包安装&lt;code&gt;lombok&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eclipse/myeclipse&lt;/code&gt;手动安装&lt;code&gt;lombok&lt;/code&gt;。

&lt;ol&gt;
&lt;li&gt;将&lt;code&gt;lombok.jar&lt;/code&gt;复制到&lt;code&gt;myeclipse.ini/eclipse.ini&lt;/code&gt;所在的文件夹目录下&lt;/li&gt;
&lt;li&gt;打开&lt;code&gt;eclipse.ini/myeclipse.ini&lt;/code&gt;，在最后面插入以下两行并保存：&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;-Xbootclasspath/a:lombok.jar
-javaagent:lombok.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后重启&lt;code&gt;eclipse/myeclipse&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;zookeeper的安装和配置:1370e1c2bb52dcdda68d1c916daa26e4&#34;&gt;Zookeeper的安装和配置&lt;/h2&gt;

&lt;p&gt;参考资料：&lt;a href=&#34;http://blog.csdn.net/shatelang/article/details/7596007&#34;&gt;http://blog.csdn.net/shatelang/article/details/7596007&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;快速配置:1370e1c2bb52dcdda68d1c916daa26e4&#34;&gt;快速配置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;下载解压到指定目录&lt;/li&gt;
&lt;li&gt;配置&lt;code&gt;bin&lt;/code&gt;：&lt;code&gt;zkServer.cmd(zkServer.sh)&lt;/code&gt;，默认不需要修改，默认读&lt;code&gt;zoo.cfg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置&lt;code&gt;conf&lt;/code&gt;：&lt;code&gt;zoo.cfg&lt;/code&gt;（注意&lt;code&gt;log dataDir&lt;/code&gt;目录须先建）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;tickTime=2000
initLimit=10
syncLimit=5
dataDir=D:\\javawork\\zookeeper-3.4.6\\data
dataLogDir=D:\\javawork\\zookeeper-3.4.6\\log
clientPort=2181
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;启动：&lt;code&gt;zkServer.cmd(zkServer.sh)&lt;/code&gt;，无报错。&lt;/li&gt;
&lt;li&gt;验证：&lt;code&gt;JPS&lt;/code&gt;，存在&lt;code&gt;QuorumPeerMain&lt;/code&gt;为已启动；验证端口&lt;code&gt;netstat -ano|findstr 2181&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../../img/quick_start_03.png&#34; alt=&#34;quick_start_03&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端命令&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo ruok|nc 127.0.0.1 2181
zkCli –server 127.0.0.1:2181
zkCli.cmd –server 127.0.0.1:2181
zkCli.cmd –server 127.0.0.1:2182
zkCli.cmd –server 127.0.0.1:2183
zkCli.cmd –server 127.0.0.1:2181 连接
zkCli.cmd
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;命令行工具的一些简单操作:1370e1c2bb52dcdda68d1c916daa26e4&#34;&gt;命令行工具的一些简单操作&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;显示根目录下文件： &lt;code&gt;ls /&lt;/code&gt; 使用&lt;code&gt;ls&lt;/code&gt;命令来查看当前&lt;code&gt;ZooKeeper&lt;/code&gt;中所包含的内容。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显示根目录下文件： &lt;code&gt;ls2 /&lt;/code&gt; 查看当前节点数据并能看到更新次数等数据。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建文件，并设置初始内容： &lt;code&gt;create /zk &amp;quot;test&amp;quot;&lt;/code&gt; 创建一个新的&lt;code&gt;znode&lt;/code&gt;节点&lt;code&gt;zk&lt;/code&gt;以及与它关联的字符串。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取文件内容： &lt;code&gt;get /zk&lt;/code&gt; 确认&lt;code&gt;znode&lt;/code&gt;是否包含我们所创建的字符串。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改文件内容： &lt;code&gt;set /zk &amp;quot;zkbak&amp;quot;&lt;/code&gt; 对&lt;code&gt;zk&lt;/code&gt;所关联的字符串进行设置。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除文件： &lt;code&gt;delete /zk&lt;/code&gt; 将刚才创建的&lt;code&gt;znode&lt;/code&gt;删除。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;退出客户端： &lt;code&gt;quit&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;帮助命令： &lt;code&gt;help&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;伪集群配置:1370e1c2bb52dcdda68d1c916daa26e4&#34;&gt;伪集群配置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;cmd&lt;/code&gt;配置3个&lt;code&gt;zkServer1.cmd zkServer2.cmd zkServer3.cmd&lt;/code&gt;，各自增加&lt;code&gt;set ZOOCFG=..\conf\zoo1.cfg&lt;/code&gt;读不同配置文件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置&lt;code&gt;conf&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;tickTime=2000
initLimit=10
syncLimit=5
dataDir=D:\\javawork\\zookeeper-3.4.6\\data\\1
dataLogDir=D:\\javawork\\zookeeper-3.4.6\\log\\1
clientPort=2181
server.1=127.0.0.1:2887:3887
server.2=127.0.0.1:2888:3888
server.3=127.0.0.1:2889:3889
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;tickTime=2000
initLimit=10
syncLimit=5
dataDir=D:\\javawork\\zookeeper-3.4.6\\data\\2
dataLogDir=D:\\javawork\\zookeeper-3.4.6\\log\\2
clientPort=2182
server.1=127.0.0.1:2887:3887
server.2=127.0.0.1:2888:3888
server.3=127.0.0.1:2889:3889
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;tickTime=2000
initLimit=10
syncLimit=5
dataDir=D:\\javawork\\zookeeper-3.4.6\\data\\3
dataLogDir=D:\\javawork\\zookeeper-3.4.6\\log\\3
clientPort=2183
server.1=127.0.0.1:2887:3887
server.2=127.0.0.1:2888:3888
server.3=127.0.0.1:2889:3889
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dataDir&lt;/code&gt;目录 需要建&lt;code&gt;myid&lt;/code&gt;文件，内容对应为服务器序列。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../../img/quick_start_04.png&#34; alt=&#34;quick_start_04&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;启动3个服务，&lt;code&gt;zkServer1.cmd zkServer2.cmd zkServer3.cmd&lt;/code&gt;，过程会有报错，等3个全启就不会报错了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../../img/quick_start_05.png&#34; alt=&#34;quick_start_05&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;启动elastic-job-example:1370e1c2bb52dcdda68d1c916daa26e4&#34;&gt;启动elastic-job-example&lt;/h2&gt;

&lt;p&gt;其中&lt;code&gt;reg.properties&lt;/code&gt;为注册服务配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;serverLists=localhost:2181               #对应各自服务器的zookeeper ip端口
namespace=elasticjob-dexotrip            #命名空间，用于注册的时候连接
baseSleepTimeMilliseconds=1000
maxSleepTimeMilliseconds=3000
maxRetries=3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;job.properties&lt;/code&gt;为作业配置&lt;/p&gt;

&lt;p&gt;启动应用：&lt;code&gt;SpringJobMainWthNamespace&lt;/code&gt;或者&lt;code&gt;SpringJobMainWthoutNamespace&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;启动elastic-job-console:1370e1c2bb52dcdda68d1c916daa26e4&#34;&gt;启动elastic-job-console&lt;/h2&gt;

&lt;p&gt;访问&lt;code&gt;http://localhost:8080/elastic-job-console/&lt;/code&gt;，用户名密码为&lt;code&gt;root/root&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注册连接信息，对应各自应用服务的配置&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/quick_start_web_console_01.png&#34; alt=&#34;quick_start_web_console_01&#34; /&gt;&lt;/p&gt;

&lt;p&gt;连接上，自动把当前的相关服务和作业信息加载。可以在里面启停服务，启停作业，修改作业参数，查看服务，作业状态等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/quick_start_web_console_02.png&#34; alt=&#34;quick_start_web_console_02&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/quick_start_web_console_03.png&#34; alt=&#34;quick_start_web_console_03&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/quick_start_web_console_04.png&#34; alt=&#34;quick_start_web_console_04&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../img/quick_start_web_console_05.png&#34; alt=&#34;quick_start_web_console_05&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3种作业类型的区别:1370e1c2bb52dcdda68d1c916daa26e4&#34;&gt;3种作业类型的区别&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;../../img/quick_start_06.png&#34; alt=&#34;quick_start_06&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;simple类型作业:1370e1c2bb52dcdda68d1c916daa26e4&#34;&gt;Simple类型作业&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Simple&lt;/code&gt;类型作业意为简单实现，未经任何封装的类型。需要继承&lt;code&gt;AbstractSimpleElasticJob&lt;/code&gt;，该类只提供了一个方法用于覆盖，此方法将被定时执行。用于执行普通的定时任务，与&lt;code&gt;Quartz&lt;/code&gt;原生接口相似，只是增加了弹性扩缩容和分片等功能。&lt;/p&gt;

&lt;h3 id=&#34;throughputdataflow类型作业:1370e1c2bb52dcdda68d1c916daa26e4&#34;&gt;ThroughputDataFlow类型作业&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ThroughputDataFlow&lt;/code&gt;类型作业意为高吞吐的数据流作业。需要继承&lt;code&gt;AbstractThroughputDataFlowElasticJob&lt;/code&gt;并可以指定返回值泛型，该类提供3个方法可覆盖，分别用于抓取数据，处理数据和指定是否流式处理数据。可以获取数据处理成功失败次数等辅助监控信息。如果流式处理数据，&lt;code&gt;fetchData&lt;/code&gt;方法的返回值只有为&lt;code&gt;null&lt;/code&gt;或长度为空时，作业才会停止执行，否则作业会一直运行下去；非流式处理数据则只会在每次作业执行过程中执行一次&lt;code&gt;fetchData&lt;/code&gt;方法和&lt;code&gt;processData&lt;/code&gt;方法，即完成本次作业。流式数据处理参照&lt;code&gt;TbSchedule&lt;/code&gt;设计，适用于不间歇的数据处理。&lt;/p&gt;

&lt;p&gt;作业执行时会将&lt;code&gt;fetchData&lt;/code&gt;的数据传递给&lt;code&gt;processData&lt;/code&gt;处理，其中&lt;code&gt;processData&lt;/code&gt;得到的数据是通过多线程（线程池大小可配）拆分的。如果采用流式作业处理方式，建议&lt;code&gt;processData&lt;/code&gt;处理数据后更新其状态，避免&lt;code&gt;fetchData&lt;/code&gt;再次抓取到，从而使得作业永远不会停止。&lt;code&gt;processData&lt;/code&gt;的返回值用于表示数据是否处理成功，抛出异常或者返回&lt;code&gt;false&lt;/code&gt;将会在统计信息中归入失败次数，返回&lt;code&gt;true&lt;/code&gt;则归入成功次数。&lt;/p&gt;

&lt;h3 id=&#34;sequencedataflow类型作业:1370e1c2bb52dcdda68d1c916daa26e4&#34;&gt;SequenceDataFlow类型作业&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;SequenceDataFlow&lt;/code&gt;类型作业和&lt;code&gt;ThroughputDataFlow&lt;/code&gt;作业类型极为相似，所不同的是&lt;code&gt;ThroughputDataFlow&lt;/code&gt;作业类型可以将获取到的数据多线程处理，但不会保证多线程处理数据的顺序。如：从&lt;code&gt;2&lt;/code&gt;个分片共获取到&lt;code&gt;100&lt;/code&gt;条数据，第&lt;code&gt;1&lt;/code&gt;个分片&lt;code&gt;40&lt;/code&gt;条，第&lt;code&gt;2&lt;/code&gt;个分片&lt;code&gt;60&lt;/code&gt;条，配置为&lt;code&gt;2&lt;/code&gt;个线程处理，则第&lt;code&gt;1&lt;/code&gt;个线程处理前&lt;code&gt;50&lt;/code&gt;条数据，第&lt;code&gt;2&lt;/code&gt;个线程处理后&lt;code&gt;50&lt;/code&gt;条数据，无视分片项；&lt;code&gt;SequenceDataFlow&lt;/code&gt;类型作业则根据当前服务器所分配的分片项数量进行多线程处理，每个分片项使用同一线程处理，防止了同一分片的数据被多线程处理，从而导致的顺序问题。如：从&lt;code&gt;2&lt;/code&gt;个分片共获取到&lt;code&gt;100&lt;/code&gt;条数据，第&lt;code&gt;1&lt;/code&gt;个分片&lt;code&gt;40&lt;/code&gt;条，第&lt;code&gt;2&lt;/code&gt;个分片&lt;code&gt;60&lt;/code&gt;条，则系统自动分配&lt;code&gt;2&lt;/code&gt;个线程处理，第&lt;code&gt;1&lt;/code&gt;个线程处理第&lt;code&gt;1&lt;/code&gt;个分片的&lt;code&gt;40&lt;/code&gt;条数据，第&lt;code&gt;2&lt;/code&gt;个线程处理第&lt;code&gt;2&lt;/code&gt;个分片的&lt;code&gt;60&lt;/code&gt;条数据。由于&lt;code&gt;ThroughputDataFlow&lt;/code&gt;作业可以使用多于分片项的任意线程数处理，所以性能调优的可能会优于&lt;code&gt;SequenceDataFlow&lt;/code&gt;作业。&lt;/p&gt;

&lt;p&gt;分数据处理，需要自己实现，可以根据分片的&lt;code&gt;ID&lt;/code&gt;位数，对应数据的位数进行处理。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>